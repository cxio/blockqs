# 区块查询服务（Blockqs）

## 前言

区块链是去中心化的，构成去中心化网络的节点应当是大众化的。

作为一个持续长久运行的区块链系统，区块数据持续增长。理论上，所有的区块数据都应当完整无缺，这对一个大众化的普通节点来说不易承受。

如果可以将区块数据从区块链中剥离出来，由一个公共的存储服务系统负责，让大众化的节点也可以轻松运行校验，很有意义。

> **注：**
> UTXO指纹设计可以让普通节点轻松完成当前UTXO集合的校验。


## 数据流

区块查询服务针对某个具体的区块链，服务器存储完整的区块及其附件数据。

服务器提供高效的检索能力，小附件（<2MB）可以直接获取，2-10MB的附件也可以直接获取，但也可能作为大附件通过P2P文件分享（`Archives`）的方式提供。

服务器也可以提供多个区块链的服务，这由服务器的硬件性能和配置决定。这里只需针对单一区块链进行设计即可。


### 数据获取

服务器通过*数据网络*的P2P分享方式获取区块和附件数据。如下图：

```go
            -->（探 测 包）-->
校验组（区块&附件） <==> 驿站 <======> 数据网 <======> 驿站 <==> Blockqs（发现区块&附件）
    |                                        <--（询 问 包）<--       |
    |                         P2P 数据传输                            |
    +--------------------------------------------------------------->>
                          (block, attachment)
```

当区块链系统中的校验组完成一个区块打包时，即向数据网络发送一个探测包，触发数据的无源上传。

> **无源上传**
> 数据网络里的驿站节点会评估该探测包，如果是自己需要的，则启动询问&获取流程。
> 因为并没有一个事先确定的需求源，故称为**无源上传**。详见数据驿站设计。


### 数据服务

服务器提供两种服务途径：

1. **实时服务**：就像普通的Web服务器一样，客户端连接服务器，获取所需的数据。这适用于交易数据和小的附件。
2. **文档分享**：对于较大的文件，比如一个完整的区块或较大的附件，实时服务并不理想。此时即由P2P文件分享机制负责。

```go
                    (transaction, little attachment...）
用户（Client） <----------------------------------------------- Blockqs (Server)
    |                                                                 |
    |                   (block, large attachment)                     |
    <<----------------------------------------------------------------+
                      P2P 数据传输 （<==> 数据网 <==>）
```

需要实时服务的通常是区块交易的校验节点，它们主要是获取交易数据本身。

对于完整区块或附件的请求，通常是普通的账户节点（钱包）或第三方应用。它们对实时性的要求并不苛刻。



## 区块存储

### 交易数据

区块链的核心是交易，因此这里以交易为基本单元进行存储。

除顶层年度外，向下为三级分层，末端即包含特定交易ID的子目录。三级分层按交易ID的前3字节切分。

```go
2025/                                   // 年度（按所在区块）
    [TxID:0xff]/                        // 一级：16进制串，小写，前置 0x
        [TxID:FF]/                      // 二级：16进制串大写
            [TxID:000]/                 // 三级：10进制3位数字串
                [TxID]/                 // 数据目录，全ID序列
                    TxID[0:16].data     // 交易数据，文件名取ID前16字节16进制串，小写
                    TxID[0:16].sig      // 签名数据，后期可删除
                    TxID[0:16].meta     // 交易的元信息，包含交易所在区块号、时间戳、总金额等基本信息
                    chksum.list         // 各文件校验和只读，可选
```

> #### 关于年度
> 顶层设计年度分级，主要是为了方便管理。区块有固定的时间间隔，因此很容易计算出来。


### 基础数据

作为每个上线节点都需要的基础数据，区块头链和UTXO集也单独存储。

```go
// 区块头链
// 用创始区块ID检索，附带起始高度。
2025/                               // 年度（区块）
    blocks.head                     // 本年度区块头链数据，按恒星年计87661个区块头，不到7MB
    chksum.txt                      // 上面头链数据的校验和存储，可选

// UTXO 集
// 在内存中构建的单独缓存，为当前（末端区块后）最新状态集。
// 此结构用于计算UTXO指纹。
2025/                               // 年度（按所在区块）
    [TxID:255]/                     // 一级：交易ID首字节分组，十进制数字
        [TxID:255]/                 // 二级：次字节分组
            [TxID:255]/             // 三级：第三字节分组
                [TxID]:(n)[...]     // 末端：特定交易输出花费状态位集，会实时更新，
                                    // n: 后续标记位的字节数，通常为1~2字节。
```

> **提示：**
> UTXO集是当前最新状态缓存，各历史区块的UTXO集可由当前序列结合上一区块内容逆向逐块推导出来。


### 区块索引

为便于同类节点同步完整的区块链数据，也应当存储一个区块的引用结构。

```go
2025/                       // 年度（区块）
    001/                    // 日次：365 ~ 366，按日历计算
        [height].txlist     // 区块：目标高度区块的交易ID清单
        ...                 // 按8分钟间隔，每日180个区块
        chksum.list         // 各文件校验和只读，可选
```

> **注：**
> .txs 文件中的交易ID顺序与其在区块中计算哈希树时的顺序一致（可能有序）。
> .txmap 文件中包含交易ID映射的接收者地址集，其中键值为简短形式（不重复的最短形式）。


### 附件档案

交易中的附件仅表示为一个ID（附件数据的哈希摘要），附件本身存储于区块链之外。这是为了区块链主体系统的简洁和高效。

附件的大小没有限制，但在交易中有所说明：存在于附件ID的末尾。

附件是一种存档逻辑，由P2P的方式通过数据网上传。太大的附件通常不提供实时检索的能力，而是以P2P的方式获取。详见 [Archives](https://github.com/cxio/archives) 项目。

> **注：**
> 附件的上传类似于区块：由交易的构造者向数据网发出探测包，激活无源上传。


### 地址关联

一个普通的用户需要根据自己的账号地址找到相关联的交易，这需要服务器创建某种地址关联。

```go
2025/                       // 年度（区块）
    001/                    // 日次：365 ~ 366
        [height].txmap      // 区块内接收者清单：交易ID => [...]
        ...                 //
        chksum.list         // 各文件校验和只读，可选
```

> #### 模糊保护
> .txmap 文件中的交易ID和账户地址仅为片段，以一定的模糊性保护隐私。其中：
> - 交易ID：[:6]。前端6字节，使得在单年度内无需再清晰。
> - 账户地址：[:14]。前端14字节，在足够的时间广度上不重复，便于准确判断。

用户可以通过下载各个区块的地址映射包，在本地发掘自己账号关联的交易ID片段，然后用足够短的交易ID片段检索交易ID集（见下）。

<!--
模糊保护借鉴于Bitcion中的过滤器（`BIP_157/158`）设计。
-->

因为存在年度的顶层分级，用户可以从自己账户创建的年度开始下载即可，并且不一定要下载完起始年度之后的全部地址映射包。结合当前UTXO集的检索对比，可以有选择性的提前终止映射包的下载。

> **注：**
> UTXO集也有顶层年度分级，也可局部下载。而且年代越久，数据量就越少。



## 数据检索

校验组会缓存当前UTXO集、管理者交易集，任何校验节点会缓存区块头链。但还是有不少数据需要向公共服务器查询。

下面是公共服务器（Blockqs）需要提供的检索条目：

- **脚本 <= 年度+交易ID+输出偏移（Y322）**：通用的交易（及其输出项）检索。
- **交易 <= 年度+交易ID**：检索完整的交易数据，可能用于第三方App（如存证验证/发展），从交易的局部信息来检索。
- **区块 <= 区块号 | 区块ID**：对一个区块的完整获取，可能源于其它数据节点的同步或第三方应用的需求。
- **区块头链 <= 创始块ID**：主要由初始上线节点下载此基准数据，用于其它下载和验证的基准。如局部链段或UTXO集等。
- **UTXO <= 交易ID+输出偏移**：查询目标是否已花费。数据节点保有一份当前最新UTXO集的副本，但这可能只是附加服务（因为实时性不强）。
- **UTXO集 <= 创始块ID**：获取最新UTXO集。主要为新上线的校验组初始化UTXO缓存（也可向同类节点获取）。
- **交易ID组 <= 年度+交易ID片段**：片段指交易ID的前段局部，相同前段的交易ID视为组。主要用于普通用户检索账号关联的交易。
- **附件 <= 附件ID**：数据量不大的附件可以通过服务器直接检索获取，大尺寸的只能以P2P的方式从数据网获取。


### 账户关联交易

普通用户可以从地址关联包中找到自己账户地址对应的交易ID片段，然后通过该片段向服务器检索对应年度内该片段的交易ID组。这可能对应多个ID，因此实现了一种模糊的隐私保护。

交易ID片段最长6字节，在一个年度内可能已经太清晰，如果用户需要更多的模糊性，可以仅用3~4字节检索（前段截取）。

返回的**交易ID组**包含了完整的ID，所在的区块高度（可能还有时间戳）。这样用户就可以交叉对比找到自己账号关联的交易了。


### 由交易查询区块

如果知道一笔交易的ID及其时间戳，可以计算出所在年度，然后查询交易数据，从其.meta文件中提取所在区块号。

如果时间戳处于年末，可能需要查询次年。但年初的交易时间戳，无需担心会被存储在前一年（区块不收录未来的交易）。



## 附：UTXO指纹

UTXO是区块链所有未花费输出的集合，为了对当前UTXO集进行高效验证，添加了UTXO指纹设计。


### UTXO指纹结构图

<img src="utxohash-1180x700.svg" width="1180" alt="UTXO指纹结构" style="background-color:#333; padding:20px; border-radius: 20px;" />

这是一个四级分层树容器，末端的交易数据文件中存储着交易的输出指引（未花费标记）。

末端目录内所有的输出指引合并计算哈希值，上级汇总计算当前目录内子哈希的哈希值，逐级向上得到根哈希，即为UTXO指纹。

这其实是一个宽成员的哈希校验树，总共四层的分级可减少每次输出指引改变带来的重新计算的数据量。顶层为年度，虽然是一个无限增长的序列，但粒度足够大。


### 意义

UTXO指纹会对区块链末端产生合法性约束，实际上，它有些像全链交易历史的当前总结。正因如此，一个刚刚上线的节点可以请求并不太多的数据量（区块头链、末端11个区块、以及当前UTXO集合），就可以大致确定目标主链是否合法。然后再同步其它区块进行完整校验（如果必要的话）。

这可以极大地降低新节点上线入网的门槛，提升区块链系统的整体效率。


### UTXO指纹的循环递进约束

> #### 当前区块与当前UTXO集合
> 当前区块是指当前正在验证交易数据，即将创建的区块。当前UTXO集合是当前区块所依据的UTXO集合，它尚未减去当前区块所收录交易的花费。
> 当前UTXO集去除掉当前区块收录交易的花费，加上新的输出和当前区块的Coinbase铸币，就成为当前区块成块之后的UTXO结果集。

当前区块的UTXO指纹从当前UTXO集合计算而来，该集合是上一区块完成之后的UTXO结果集（而不是本区块完成之后的结果集）。

这样的设计可以为UTXO指纹计算留出足够的时间，而同时也获得了一种循环递进的约束：攻击者无法在剔除或加入一笔交易的同时，维持影响仅限于本区块（假如哈希碰撞被悄悄实现的话）。这相当于区块链的哈希链式锁定不止限于区块ID本身，也包含UTXO指纹的链式约束。这算是一种双锁定吧。


#### 推导流程示例

- 假设当前区块为101号，当前UTXO集即为第100号区块的UTXO结果集。
- 当前UTXO集减去第100号区块的新输出和Coinbase铸币、加上第100号区块的输入花费，可得到第100号区块的当前UTXO集。
- 计算这个集合的指纹，它应当与第100号区块记录的UTXO指纹相同。这样就验证了（101号区块的）当前UTXO集合的合法性。
- 如果再用第100号区块的当前UTXO集减去第99号区块的新输出和Coinbase铸币，以及同样的输入处理，就可以验证第100号区块的当前UTXO集。
- 如此循环递进，我们就可以从一个最新的UTXO集合逆向验证区块链至任意历史位置。

另外，UTXO指纹表达的是上一区块的UTXO结果集，这使得指纹的约束是链式的，攻击者无法通过单个区块的交易ID塑造来匹配UTXO指纹。
